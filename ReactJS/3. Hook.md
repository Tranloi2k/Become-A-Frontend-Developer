# Hook trong React

## 1. useState

**Định nghĩa:** Hook dùng để thêm state (trạng thái) vào functional component. Trả về một mảng gồm giá trị hiện tại và hàm setter để cập nhật giá trị đó.

**Ví dụ:**
```jsx
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleLogin = async () => {
    setIsLoading(true);
    setIsLoading(false);
  };
```

---

## 2. useEffect

**Định nghĩa:** Hook để thực hiện side effects (tác dụng phụ) trong functional component. Chạy sau khi component render và có thể cleanup khi component unmount.

**Use case:**
- Fetch data từ API khi component mount
- Subscription/cleanup (WebSocket, timers, event listeners)
- Cập nhật document title
- Theo dõi sự thay đổi của props/state

**Ví dụ:**
```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    if (userId) {
      fetch(`/api/users/${userId}`)
        .then(res => res.json())
        .then(setUser);
    }
  }, [userId]);
}
```

---

## 3. useContext

**Định nghĩa:** Hook để truy cập giá trị từ React Context mà không cần sử dụng Context.Consumer, giúp chia sẻ dữ liệu toàn cục giữa các component.

**Use case:**
- Quản lý authentication state toàn cục
- Theme switching (dark/light mode)
- Multi-language (i18n)
- Shopping cart data
- User preferences

**Ví dụ:**
```jsx
const ThemeContext = createContext();

function App() {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Header />
      <Content />
    </ThemeContext.Provider>
  );
}

function Header() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
   ...
  );
}
```

---

## 4. useRef

**Định nghĩa:** Hook tạo ra một ref object có thuộc tính `.current` để tham chiếu đến DOM element hoặc lưu trữ giá trị mutable mà không trigger re-render.

**Use case:**
- Focus vào input elements
- Scroll đến một vị trí cụ thể
- Lưu trữ timer IDs, previous values
- Tích hợp với thư viện bên ngoài (DOM manipulation)
- Đo lường kích thước element

**Ví dụ:**
```jsx
function SearchInput() {
  const inputRef = useRef();
  const countRef = useRef(0);

  const focusInput = () => {
    inputRef.current.focus();
  };

  const handleSearch = () => {
    countRef.current += 1;
    // countRef thay đổi nhưng không trigger re-render
  };

  return (
    <div>
      <input ref={inputRef} placeholder="Tìm kiếm..." />
      <button onClick={focusInput}>Focus Input</button>
      <button onClick={handleSearch}>Search</button>
    </div>
  );
}
```

---

## 5. useMemo

**Định nghĩa:** Hook để memoize (cache) kết quả của một phép tính expensive, chỉ tính toán lại khi dependencies thay đổi, giúp tối ưu hiệu năng.

**Use case:**
- Filter/sort danh sách lớn
- Tính toán phức tạp (mathematical operations)
- Transform data cho charts/graphs
- Expensive object/array operations
- Format dữ liệu hiển thị

**Ví dụ:**
```jsx
const Child = ({ data }) => {};
const ChildMemo = React.memo(Child);

function ProductList({ products, searchTerm, sortBy }) {
  const filteredProducts = useMemo(() => {
    return products
      .filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()))
      .sort((a, b) => a[sortBy] - b[sortBy]);
  }, [products, searchTerm, sortBy]);

  return <ChildMemo data={filteredProducts} />
}
```

---

## 6. useCallback

**Định nghĩa:** Hook để memoize function, tránh tạo lại function mới trong mỗi lần render, đặc biệt hữu ích khi truyền function làm props cho child component đã được memo.

**Use case:**
- Event handlers cho React.memo components
- Function dependencies trong useEffect
- Prevent unnecessary re-renders của child components
- Callback functions cho third-party libraries

**Ví dụ:**
```jsx

const AddTodoForm = ({ onAdd }) => {};
const AddTodoFormMemo = React.memo(AddTodoForm);

function TodoApp() {
  const [todos, setTodos] = useState([]);

  const addTodo = useCallback((text) => {
    setTodos(prev => [...prev, { id: Date.now(), text, completed: false }]);
  }, []);

  return (
    <div>
      <AddTodoFormMemo onAdd={addTodo} />
    </div>
  );
}

// Component được memo sẽ không re-render nếu props không đổi
const AddTodoForm = React.memo(({ onAdd }) => {
  const [text, setText] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      onAdd(text);
      setText('');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Thêm Todo</button>
    </form>
  );
});
```

---

## 7. useReducer

**Định nghĩa:** Hook để quản lý state phức tạp thông qua reducer function, tương tự Redux pattern. Nhận vào reducer function và initial state, trả về current state và dispatch function.

**Use case:**
- Form phức tạp với nhiều fields và validation
- Shopping cart với multiple actions
- Game state management
- Complex UI state (modal, wizard, multi-step form)
- State với logic cập nhật phức tạp

**Ví dụ:**
```jsx
const initialState = { items: [], total: 0 };

function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      const newItems = [...state.items, action.item];
      return {
        items: newItems,
        total: newItems.reduce((sum, item) => sum + item.price * item.quantity, 0)
      };
    
    case 'REMOVE_ITEM':
      const filteredItems = state.items.filter(item => item.id !== action.id);
      return {
        items: filteredItems,
        total: filteredItems.reduce((sum, item) => sum + item.price * item.quantity, 0)
      };
    
    case 'CLEAR_CART':
      return initialState;
    
    default:
      return state;
  }
}

function ShoppingCart() {
  const [cart, dispatch] = useReducer(cartReducer, initialState);

  const addItem = (item) => {
    dispatch({ type: 'ADD_ITEM', item });
  };

  const removeItem = (id) => {
    dispatch({ type: 'REMOVE_ITEM', id });
  };

  return (
    ...
  );
}
```

---

## Tóm tắt khi nào nên dùng Hook nào

| Tình huống | Hook phù hợp | Lý do |
|------------|--------------|-------|
| Form input đơn giản | `useState` | Quản lý state cơ bản |
| Gọi API khi mount | `useEffect` | Side effect khi component khởi tạo |
| Chia sẻ data toàn cục | `useContext` | Tránh prop drilling |
| Focus input, scroll | `useRef` | Tương tác với DOM |
| Filter danh sách lớn | `useMemo` | Tối ưu tính toán expensive |
| Props cho memo component | `useCallback` | Tránh re-render không cần thiết |
| State logic phức tạp | `useReducer` | Quản lý state có nhiều action |

---

**Ghi chú:** Tài liệu này được tạo bởi @Tranloi2k vào ngày 2025-09-22. Các ví dụ được thiết kế ngắn gọn và thực tế để dễ hiểu và áp dụng.
