# React Context API: Hướng dẫn chi tiết

---

## 1. Context API là gì?

**Định nghĩa:** **Context API** là một tính năng của React cho phép bạn truyền dữ liệu qua cây component mà không cần phải truyền `props` thủ công qua từng cấp.

Bạn có thể hình dung Context như một "kênh thông tin" hoặc một "biến toàn cục" cho một nhánh của cây component. Bất kỳ component nào trong nhánh đó, dù ở sâu đến đâu, đều có thể "đăng ký" để nhận dữ liệu từ kênh này.

Context API bao gồm 3 phần chính:
1.  **`React.createContext()`**: Hàm để tạo ra một đối tượng Context.
2.  **`<Context.Provider>`**: Một component dùng để "phát sóng" dữ liệu. Nó bao bọc các component con và cung cấp một `value` cho chúng.
3.  **`<Context.Consumer>`** hoặc **`useContext()` Hook**: Các component con dùng một trong hai cách này để "lắng nghe" và nhận dữ liệu từ `Provider` gần nhất. `useContext()` là cách hiện đại và phổ biến hơn.

---

## 2. Vấn đề Context API giải quyết: "Prop Drilling"

Context API sinh ra chủ yếu để giải quyết một vấn đề rất phổ biến trong React gọi là **"Prop Drilling"** (Khoan props).

### Prop Drilling là gì?
Đó là tình huống khi bạn phải truyền `props` qua nhiều cấp component trung gian chỉ để đưa dữ liệu từ một component cha ở trên cao xuống một component con ở rất sâu bên dưới. Các component trung gian này không hề sử dụng `props` đó, chúng chỉ có nhiệm vụ "chuyền tay" nó đi tiếp.

**Ví dụ về Prop Drilling:**

Hãy tưởng tượng cấu trúc component sau, bạn muốn truyền `userInfo` từ `App` xuống `Avatar`:

```
App (có userInfo)
└──> Header (không dùng userInfo, chỉ truyền xuống)
     └──> UserMenu (không dùng userInfo, chỉ truyền xuống)
          └──> Avatar (cần userInfo để hiển thị ảnh)
```

### Giải quyết bằng Context API:
```jsx
// 1. Tạo Context
const UserContext = React.createContext();

// 2. Dùng Provider ở component cha
function App() {
  const userInfo = { name: 'Lợi Trần', avatarUrl: '...' };
  return (
    <UserContext.Provider value={userInfo}>
      <User />
    </UserContext.Provider>
  );
}

function User() {
  const userInfo = useContext(UserContext); // Lấy thẳng dữ liệu từ Context
  return <img src={userInfo.avatarUrl} alt={userInfo.name} />;
}
```

---

## 3. Những lưu ý quan trọng khi dùng Context API trong thực tế

1.  **Không lạm dụng Context:** Context rất hữu ích, nhưng không phải là giải pháp cho mọi trường hợp. Nếu bạn chỉ cần truyền props qua 1-2 cấp, hãy cứ dùng props bình thường. Việc tạo Context cho mọi thứ sẽ làm code khó theo dõi hơn.
    *   **Chỉ dùng Context cho dữ liệu thực sự "toàn cục"** như: thông tin người dùng đã đăng nhập, theme (dark/light mode), ngôn ngữ, cài đặt...

2.  **Context không phải là một thư viện quản lý state (như Redux, Zustand):** Context chỉ là cơ chế truyền dữ liệu. Nó không cung cấp các công cụ mạnh mẽ như middleware, devtools, hay logic xử lý action phức tạp. Với các ứng dụng lớn có state phức tạp, việc kết hợp Context với `useReducer` hoặc dùng các thư viện chuyên dụng vẫn là lựa chọn tốt hơn.

3.  **Tách nhỏ các Context:** Đừng tạo một Context "Thần Thánh" chứa tất cả mọi thứ.
    *   **Tệ:** `AppContext = { theme, user, language, settings, ... }`
    *   **Tốt:** Tạo riêng `ThemeContext`, `AuthContext`, `LanguageContext`. Việc này giúp ngăn chặn các re-render không cần thiết (sẽ giải thích ở phần performance).

4.  **Luôn memoize giá trị của `Provider`:** Đây là một lưu ý cực kỳ quan trọng về performance. Nếu giá trị `value` là một object hoặc array, nó sẽ được tạo lại mỗi lần component cha re-render, gây ra re-render không cần thiết cho tất cả các consumer.
    ```jsx
    function App() {
      const [theme, setTheme] = useState('light');

      // Dùng useMemo để đảm bảo object `value` không bị tạo lại mỗi lần App re-render
      const themeValue = useMemo(() => ({ theme, setTheme }), [theme]);

      return (
        <ThemeContext.Provider value={themeValue}>
          {/* Các component con */}
        </ThemeContext.Provider>
      );
    }
    ```

---

## 4. Context API ảnh hưởng tới Performance như thế nào?

Đây là điểm yếu lớn nhất của Context API nếu không được sử dụng cẩn thận.

### Vấn đề cốt lõi:
Khi giá trị (`value`) của một `<Context.Provider>` thay đổi, **TẤT CẢ** các component con sử dụng `useContext` để lắng nghe Context đó sẽ bị **re-render**, bất kể chúng có thực sự sử dụng đến phần dữ liệu đã thay đổi hay không.

**Ví dụ về vấn đề performance:**
Giả sử bạn có một Context lớn: `AppContext = { user, theme }`
Một component `Header` chỉ dùng `user`, và một component `Footer` chỉ dùng `theme`.

```jsx
function Header() {
  const { user } = useContext(AppContext); // Chỉ cần user
  console.log('Header re-render');
  return <header>Xin chào, {user.name}</header>;
}

function Footer() {
  const { theme } = useContext(AppContext); // Chỉ cần theme
  console.log('Footer re-render');
  return <footer className={theme}>...</footer>;
}
```
Khi bạn thay đổi `theme`, `Footer` re-render là đúng. Nhưng `Header` cũng sẽ **bị re-render một cách không cần thiết**, vì `AppContext` đã thay đổi. Với ứng dụng lớn, điều này có thể gây ra các vấn đề nghiêm trọng về hiệu năng.

### Các giải pháp tối ưu performance:

1.  **Tách nhỏ Context (Giải pháp tốt nhất):**
    Như đã đề cập ở trên, hãy tạo `AuthContext` chứa `user` và `ThemeContext` chứa `theme`.
    ```jsx
    // Header chỉ lắng nghe AuthContext
    const { user } = useContext(AuthContext);

    // Footer chỉ lắng nghe ThemeContext
    const { theme } = useContext(ThemeContext);
    ```
    Bây giờ, khi theme thay đổi, chỉ `ThemeContext` cập nhật, và chỉ `Footer` re-render. `Header` không bị ảnh hưởng.

2.  **Memoization component con với `React.memo`:**
    Bạn có thể bọc các component con trong `React.memo` để ngăn chúng re-render nếu props không đổi. Cách này hiệu quả khi bạn có thể tách component thành hai phần: phần nhận context và phần render UI.
    ```jsx
    function UserAvatar() {
      const { user } = useContext(AuthContext);
      // Truyền user như một prop cho component được memoize
      return <MemoizedAvatar user={user} />;
    }

    // MemoizedAvatar sẽ chỉ re-render nếu prop 'user' thực sự thay đổi.
    const MemoizedAvatar = React.memo(({ user }) => {
      console.log("Avatar re-rendering only when user object changes");
      return <img src={user.avatarUrl} />;
    });
    ```

---

## Kết luận

| Ưu điểm | Nhược điểm |
|---------|------------|
| ✅ Giải quyết triệt để "Prop Drilling" | ❌ Dễ gây re-render không cần thiết nếu không cẩn thận |
| ✅ Code sạch sẽ, dễ bảo trì hơn | ❌ Không phải là giải pháp quản lý state toàn diện |
| ✅ Dễ sử dụng, tích hợp sẵn trong React | ❌ Có thể làm khó theo dõi luồng dữ liệu nếu lạm dụng |

**Tóm lại:** Context API là một công cụ tuyệt vời để quản lý dữ liệu toàn cục và tránh "prop drilling". Tuy nhiên, hãy luôn ý thức về vấn đề re-render và áp dụng các kỹ thuật tối ưu như tách nhỏ context và memoization để đảm bảo ứng dụng của bạn luôn có hiệu năng tốt.
