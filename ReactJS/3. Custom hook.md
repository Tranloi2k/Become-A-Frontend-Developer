# Custom Hooks trong React
---

## Custom Hooks là gì?

**Định nghĩa:** Custom Hooks là những JavaScript functions có tên bắt đầu bằng "use" và có thể gọi các Hooks khác bên trong. Chúng cho phép bạn tái sử dụng stateful logic giữa các component mà không cần thay đổi cấu trúc component hierarchy.

**Use case:**
- Tái sử dụng logic phức tạp giữa nhiều component
- Tách riêng business logic khỏi UI logic
- Tạo ra các API đơn giản hơn cho các tác vụ phức tạp
- Fetch data với các pattern tương tự
- Form validation và management
- Local storage synchronization
- API integration patterns

---

## Quy tắc khi tạo Custom Hooks

### 1. Quy tắc đặt tên
- **Bắt buộc:** Tên phải bắt đầu bằng "use" (ví dụ: `useAuth`, `useFetch`)
- **Lý do:** Để React có thể áp dụng các quy tắc của Hooks

### 2. Quy tắc gọi Hooks
- **Chỉ gọi ở top level:** Không gọi trong loops, conditions, hoặc nested functions
- **Thứ tự nhất quán:** Đảm bảo thứ tự gọi Hooks giống nhau giữa các lần render

### 3. Nguyên tắc thiết kế
- **Tái sử dụng logic, không phải UI:** Custom Hooks chia sẻ stateful logic, không phải JSX
- **Independent state:** Mỗi lần gọi Custom Hook tạo ra state độc lập
- **Single responsibility:** Mỗi hook nên có một mục đích rõ ràng

---

## Lợi ích của Custom Hooks

| Lợi ích | Mô tả |
|---------|--------|
| **Code reusability** | Tái sử dụng logic giữa nhiều component |
| **Separation of concerns** | Tách biệt business logic và UI logic |
| **Easier testing** | Test logic độc lập với UI |
| **Cleaner components** | Component tập trung vào render, logic ở hooks |
| **Better organization** | Nhóm related state và logic lại với nhau |

---

## Khi nào nên tạo Custom Hook?

✅ **Nên tạo khi:**
- Logic được sử dụng ở nhiều component
- Component trở nên quá phức tạp
- Cần tách biệt business logic và UI
- Muốn test logic độc lập

❌ **Không nên tạo khi:**
- Logic chỉ dùng ở một component
- Logic quá đơn giản (1-2 dòng code)
- Chưa có pattern rõ ràng để abstract

---
## 1. Custom Hook cho Fetch Data

**Định nghĩa:** Hook tùy chỉnh để xử lý việc gọi API và quản lý các trạng thái loading, error, data.

**Use case:**
- Gọi API để lấy dữ liệu từ server
- Quản lý trạng thái loading và error handling
- Tái sử dụng logic fetch data giữa các component
- Caching và retry mechanism

**Ví dụ:**
```jsx
// hooks/useFetch.js
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`Lỗi: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    if (url) {
      fetchData();
    }
  }, [url]);

  return { data, loading, error };
}

// Sử dụng trong component
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');

  if (loading) return <div>Đang tải...</div>;
  if (error) return <div>Lỗi: {error}</div>;

  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## 2. Custom Hook cho Local Storage

**Định nghĩa:** Hook để đồng bộ state với localStorage, tự động lưu và khôi phục dữ liệu.

**Use case:**
- Lưu trữ user preferences (theme, language)
- Shopping cart persistence
- Form data backup
- User settings và configuration

**Ví dụ:**
```jsx
// hooks/useLocalStorage.js
import { useState } from 'react';

function useLocalStorage(key, initialValue) {
  // Lấy giá trị từ localStorage hoặc dùng initialValue
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Lỗi đọc localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Hàm để set giá trị vào state và localStorage
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Lỗi ghi localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}

// Sử dụng trong component
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [language, setLanguage] = useLocalStorage('language', 'vi');

  return (
    <div>
      <h2>Cài đặt</h2>
      <div>
        <label>Giao diện: </label>
        <select value={theme} onChange={(e) => setTheme(e.target.value)}>
          <option value="light">Sáng</option>
          <option value="dark">Tối</option>
        </select>
      </div>
      <div>
        <label>Ngôn ngữ: </label>
        <select value={language} onChange={(e) => setLanguage(e.target.value)}>
          <option value="vi">Tiếng Việt</option>
          <option value="en">English</option>
        </select>
      </div>
    </div>
  );
}
```

---

## 3. Custom Hook cho Form Management

**Định nghĩa:** Hook quản lý form state, validation và các thao tác form phổ biến.

**Use case:**
- Quản lý form data và validation
- Handle form submission
- Field-level validation
- Form reset và error handling

**Ví dụ:**
```jsx
// hooks/useForm.js
import { useState } from 'react';

function useForm(initialValues, validationRules = {}) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const handleChange = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
    
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleBlur = (name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
    validateField(name, values[name]);
  };

  const validateField = (name, value) => {
    const rule = validationRules[name];
    if (!rule) return;

    let error = '';
    
    if (rule.required && (!value || value.trim() === '')) {
      error = rule.required;
    } else if (rule.minLength && value.length < rule.minLength) {
      error = rule.minLength;
    } else if (rule.pattern && !rule.pattern.test(value)) {
      error = rule.patternMessage || 'Định dạng không hợp lệ';
    }

    setErrors(prev => ({ ...prev, [name]: error }));
    return error === '';
  };

  const validateForm = () => {
    let isValid = true;
    Object.keys(validationRules).forEach(fieldName => {
      const isFieldValid = validateField(fieldName, values[fieldName]);
      if (!isFieldValid) isValid = false;
    });
    return isValid;
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    validateForm,
    reset,
    isValid: Object.keys(errors).length === 0
  };
}

// Sử dụng trong component
function LoginForm() {
  const validationRules = {
    email: {
      required: 'Email là bắt buộc',
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      patternMessage: 'Email không hợp lệ'
    },
    password: {
      required: 'Mật khẩu là bắt buộc',
      minLength: 'Mật khẩu phải có ít nhất 6 ký tự'
    }
  };

  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    validateForm
  } = useForm({ email: '', password: '' }, validationRules);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateForm()) {
      console.log('Đăng nhập thành công:', values);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="email"
          placeholder="Email"
          value={values.email}
          onChange={(e) => handleChange('email', e.target.value)}
          onBlur={() => handleBlur('email')}
        />
        {touched.email && errors.email && (
          <span style={{ color: 'red' }}>{errors.email}</span>
        )}
      </div>

      <div>
        <input
          type="password"
          placeholder="Mật khẩu"
          value={values.password}
          onChange={(e) => handleChange('password', e.target.value)}
          onBlur={() => handleBlur('password')}
        />
        {touched.password && errors.password && (
          <span style={{ color: 'red' }}>{errors.password}</span>
        )}
      </div>

      <button type="submit">Đăng nhập</button>
    </form>
  );
}
```

---

## 4. Custom Hook cho Toggle State

**Định nghĩa:** Hook đơn giản để quản lý boolean state với các thao tác toggle, set true/false.

**Use case:**
- Mở/đóng modal, dropdown, sidebar
- Show/hide content
- Enable/disable features
- Toggle switches và checkboxes

**Ví dụ:**
```jsx
// hooks/useToggle.js
import { useState, useCallback } from 'react';

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => setValue(prev => !prev), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return { value, toggle, setTrue, setFalse };
}

// Sử dụng trong component
function Modal() {
  const { value: isOpen, setTrue: openModal, setFalse: closeModal } = useToggle();

  return (
    <div>
      <button onClick={openModal}>Mở Modal</button>
      
      {isOpen && (
        <div className="modal-overlay" onClick={closeModal}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <h2>Đây là Modal</h2>
            <p>Nội dung modal ở đây...</p>
            <button onClick={closeModal}>Đóng</button>
          </div>
        </div>
      )}
    </div>
  );
}
```

---

## 5. Custom Hook cho Pagination

**Định nghĩa:** Hook quản lý phân trang với khả năng fetch data theo page và điều hướng giữa các trang.

**Use case:**
- Phân trang danh sách sản phẩm
- Pagination cho bảng dữ liệu
- Infinite scroll implementation
- Load more functionality

**Ví dụ:**
```jsx
// hooks/usePagination.js
import { useState, useEffect, useCallback } from 'react';

function usePagination(fetchFunction, initialPage = 1, pageSize = 10) {
  const [data, setData] = useState([]);
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [totalPages, setTotalPages] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async (page) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetchFunction({ page, limit: pageSize });
      setData(response.data);
      setTotalPages(Math.ceil(response.total / pageSize));
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [fetchFunction, pageSize]);

  useEffect(() => {
    fetchData(currentPage);
  }, [currentPage, fetchData]);

  const goToPage = (page) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
    }
  };

  const nextPage = () => currentPage < totalPages && setCurrentPage(prev => prev + 1);
  const prevPage = () => currentPage > 1 && setCurrentPage(prev => prev - 1);

  return {
    data,
    currentPage,
    totalPages,
    loading,
    error,
    goToPage,
    nextPage,
    prevPage,
    hasNext: currentPage < totalPages,
    hasPrev: currentPage > 1
  };
}

// Sử dụng trong component
function ProductList() {
  const fetchProducts = async ({ page, limit }) => {
    const response = await fetch(`/api/products?page=${page}&limit=${limit}`);
    return response.json();
  };

  const {
    data: products,
    currentPage,
    totalPages,
    loading,
    nextPage,
    prevPage,
    hasNext,
    hasPrev
  } = usePagination(fetchProducts, 1, 5);

  if (loading) return <div>Đang tải...</div>;

  return (
    <div>
      <h2>Danh sách sản phẩm</h2>
      
      <ul>
        {products.map(product => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>

      <div className="pagination">
        <button onClick={prevPage} disabled={!hasPrev}>
          ← Trang trước
        </button>
        <span>Trang {currentPage} / {totalPages}</span>
        <button onClick={nextPage} disabled={!hasNext}>
          Trang sau →
        </button>
      </div>
    </div>
  );
}
```

---

**Kết luận:** Custom Hooks là công cụ mạnh mẽ giúp code React trở nên sạch sẽ, có thể tái sử dụng và dễ maintain. Hãy sử dụng chúng để tối ưu hóa cấu trúc dự án của bạn!
